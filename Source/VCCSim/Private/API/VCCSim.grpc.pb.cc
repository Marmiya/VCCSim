// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: VCCSim.proto

#include "VCCSim.pb.h"
#include "VCCSim.grpc.pb.h"

#include <functional>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/channel_interface.h>
#include <grpcpp/impl/client_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/rpc_service_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/sync_stream.h>
namespace VCCSim {

static const char* LidarService_method_names[] = {
  "/VCCSim.LidarService/GetLiDARData",
  "/VCCSim.LidarService/GetLiDAROdom",
  "/VCCSim.LidarService/GetLiDARDataAndOdom",
};

std::unique_ptr< LidarService::Stub> LidarService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< LidarService::Stub> stub(new LidarService::Stub(channel, options));
  return stub;
}

LidarService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetLiDARData_(LidarService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetLiDAROdom_(LidarService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetLiDARDataAndOdom_(LidarService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status LidarService::Stub::GetLiDARData(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::LidarData* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::LidarData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetLiDARData_, context, request, response);
}

void LidarService::Stub::async::GetLiDARData(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::LidarData* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::LidarData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDARData_, context, request, response, std::move(f));
}

void LidarService::Stub::async::GetLiDARData(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::LidarData* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDARData_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::LidarData>* LidarService::Stub::PrepareAsyncGetLiDARDataRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::LidarData, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetLiDARData_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::LidarData>* LidarService::Stub::AsyncGetLiDARDataRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetLiDARDataRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status LidarService::Stub::GetLiDAROdom(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Odometry* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetLiDAROdom_, context, request, response);
}

void LidarService::Stub::async::GetLiDAROdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDAROdom_, context, request, response, std::move(f));
}

void LidarService::Stub::async::GetLiDAROdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDAROdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* LidarService::Stub::PrepareAsyncGetLiDAROdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Odometry, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetLiDAROdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* LidarService::Stub::AsyncGetLiDAROdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetLiDAROdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status LidarService::Stub::GetLiDARDataAndOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::LidarDataAndOdom* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::LidarDataAndOdom, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetLiDARDataAndOdom_, context, request, response);
}

void LidarService::Stub::async::GetLiDARDataAndOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::LidarDataAndOdom* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::LidarDataAndOdom, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDARDataAndOdom_, context, request, response, std::move(f));
}

void LidarService::Stub::async::GetLiDARDataAndOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::LidarDataAndOdom* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDARDataAndOdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::LidarDataAndOdom>* LidarService::Stub::PrepareAsyncGetLiDARDataAndOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::LidarDataAndOdom, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetLiDARDataAndOdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::LidarDataAndOdom>* LidarService::Stub::AsyncGetLiDARDataAndOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetLiDARDataAndOdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

LidarService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LidarService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LidarService::Service, ::VCCSim::RobotName, ::VCCSim::LidarData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](LidarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::LidarData* resp) {
               return service->GetLiDARData(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LidarService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LidarService::Service, ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](LidarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Odometry* resp) {
               return service->GetLiDAROdom(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LidarService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LidarService::Service, ::VCCSim::RobotName, ::VCCSim::LidarDataAndOdom, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](LidarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::LidarDataAndOdom* resp) {
               return service->GetLiDARDataAndOdom(ctx, req, resp);
             }, this)));
}

LidarService::Service::~Service() {
}

::grpc::Status LidarService::Service::GetLiDARData(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::LidarData* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status LidarService::Service::GetLiDAROdom(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status LidarService::Service::GetLiDARDataAndOdom(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::LidarDataAndOdom* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* DepthCameraService_method_names[] = {
  "/VCCSim.DepthCameraService/GetDepthCameraPointData",
  "/VCCSim.DepthCameraService/GetDepthCameraImageData",
  "/VCCSim.DepthCameraService/GetDepthCameraOdom",
};

std::unique_ptr< DepthCameraService::Stub> DepthCameraService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< DepthCameraService::Stub> stub(new DepthCameraService::Stub(channel, options));
  return stub;
}

DepthCameraService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetDepthCameraPointData_(DepthCameraService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetDepthCameraImageData_(DepthCameraService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetDepthCameraOdom_(DepthCameraService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status DepthCameraService::Stub::GetDepthCameraPointData(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::DepthCameraPointData* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::DepthCameraPointData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetDepthCameraPointData_, context, request, response);
}

void DepthCameraService::Stub::async::GetDepthCameraPointData(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::DepthCameraPointData* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::DepthCameraPointData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraPointData_, context, request, response, std::move(f));
}

void DepthCameraService::Stub::async::GetDepthCameraPointData(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::DepthCameraPointData* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraPointData_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::DepthCameraPointData>* DepthCameraService::Stub::PrepareAsyncGetDepthCameraPointDataRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::DepthCameraPointData, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetDepthCameraPointData_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::DepthCameraPointData>* DepthCameraService::Stub::AsyncGetDepthCameraPointDataRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetDepthCameraPointDataRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status DepthCameraService::Stub::GetDepthCameraImageData(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::DepthCameraImageData* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::DepthCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetDepthCameraImageData_, context, request, response);
}

void DepthCameraService::Stub::async::GetDepthCameraImageData(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::DepthCameraImageData* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::DepthCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraImageData_, context, request, response, std::move(f));
}

void DepthCameraService::Stub::async::GetDepthCameraImageData(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::DepthCameraImageData* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraImageData_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::DepthCameraImageData>* DepthCameraService::Stub::PrepareAsyncGetDepthCameraImageDataRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::DepthCameraImageData, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetDepthCameraImageData_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::DepthCameraImageData>* DepthCameraService::Stub::AsyncGetDepthCameraImageDataRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetDepthCameraImageDataRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status DepthCameraService::Stub::GetDepthCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Odometry* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetDepthCameraOdom_, context, request, response);
}

void DepthCameraService::Stub::async::GetDepthCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraOdom_, context, request, response, std::move(f));
}

void DepthCameraService::Stub::async::GetDepthCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraOdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* DepthCameraService::Stub::PrepareAsyncGetDepthCameraOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Odometry, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetDepthCameraOdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* DepthCameraService::Stub::AsyncGetDepthCameraOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetDepthCameraOdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

DepthCameraService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DepthCameraService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DepthCameraService::Service, ::VCCSim::RobotName, ::VCCSim::DepthCameraPointData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DepthCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::DepthCameraPointData* resp) {
               return service->GetDepthCameraPointData(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DepthCameraService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DepthCameraService::Service, ::VCCSim::RobotName, ::VCCSim::DepthCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DepthCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::DepthCameraImageData* resp) {
               return service->GetDepthCameraImageData(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DepthCameraService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DepthCameraService::Service, ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DepthCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Odometry* resp) {
               return service->GetDepthCameraOdom(ctx, req, resp);
             }, this)));
}

DepthCameraService::Service::~Service() {
}

::grpc::Status DepthCameraService::Service::GetDepthCameraPointData(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::DepthCameraPointData* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DepthCameraService::Service::GetDepthCameraImageData(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::DepthCameraImageData* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DepthCameraService::Service::GetDepthCameraOdom(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* RGBCameraService_method_names[] = {
  "/VCCSim.RGBCameraService/GetRGBCameraOdom",
  "/VCCSim.RGBCameraService/GetRGBIndexedCameraImageData",
};

std::unique_ptr< RGBCameraService::Stub> RGBCameraService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< RGBCameraService::Stub> stub(new RGBCameraService::Stub(channel, options));
  return stub;
}

RGBCameraService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetRGBCameraOdom_(RGBCameraService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetRGBIndexedCameraImageData_(RGBCameraService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status RGBCameraService::Stub::GetRGBCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Odometry* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetRGBCameraOdom_, context, request, response);
}

void RGBCameraService::Stub::async::GetRGBCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetRGBCameraOdom_, context, request, response, std::move(f));
}

void RGBCameraService::Stub::async::GetRGBCameraOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetRGBCameraOdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* RGBCameraService::Stub::PrepareAsyncGetRGBCameraOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Odometry, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetRGBCameraOdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* RGBCameraService::Stub::AsyncGetRGBCameraOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetRGBCameraOdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status RGBCameraService::Stub::GetRGBIndexedCameraImageData(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera& request, ::VCCSim::RGBCameraImageData* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::IndexedCamera, ::VCCSim::RGBCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetRGBIndexedCameraImageData_, context, request, response);
}

void RGBCameraService::Stub::async::GetRGBIndexedCameraImageData(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera* request, ::VCCSim::RGBCameraImageData* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::IndexedCamera, ::VCCSim::RGBCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetRGBIndexedCameraImageData_, context, request, response, std::move(f));
}

void RGBCameraService::Stub::async::GetRGBIndexedCameraImageData(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera* request, ::VCCSim::RGBCameraImageData* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetRGBIndexedCameraImageData_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::RGBCameraImageData>* RGBCameraService::Stub::PrepareAsyncGetRGBIndexedCameraImageDataRaw(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::RGBCameraImageData, ::VCCSim::IndexedCamera, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetRGBIndexedCameraImageData_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::RGBCameraImageData>* RGBCameraService::Stub::AsyncGetRGBIndexedCameraImageDataRaw(::grpc::ClientContext* context, const ::VCCSim::IndexedCamera& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetRGBIndexedCameraImageDataRaw(context, request, cq);
  result->StartCall();
  return result;
}

RGBCameraService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RGBCameraService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RGBCameraService::Service, ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RGBCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Odometry* resp) {
               return service->GetRGBCameraOdom(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RGBCameraService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RGBCameraService::Service, ::VCCSim::IndexedCamera, ::VCCSim::RGBCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RGBCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::IndexedCamera* req,
             ::VCCSim::RGBCameraImageData* resp) {
               return service->GetRGBIndexedCameraImageData(ctx, req, resp);
             }, this)));
}

RGBCameraService::Service::~Service() {
}

::grpc::Status RGBCameraService::Service::GetRGBCameraOdom(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status RGBCameraService::Service::GetRGBIndexedCameraImageData(::grpc::ServerContext* context, const ::VCCSim::IndexedCamera* request, ::VCCSim::RGBCameraImageData* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* DroneService_method_names[] = {
  "/VCCSim.DroneService/GetDronePose",
  "/VCCSim.DroneService/SendDronePose",
  "/VCCSim.DroneService/SendDronePath",
};

std::unique_ptr< DroneService::Stub> DroneService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< DroneService::Stub> stub(new DroneService::Stub(channel, options));
  return stub;
}

DroneService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetDronePose_(DroneService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendDronePose_(DroneService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendDronePath_(DroneService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status DroneService::Stub::GetDronePose(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Pose* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Pose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetDronePose_, context, request, response);
}

void DroneService::Stub::async::GetDronePose(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Pose* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Pose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDronePose_, context, request, response, std::move(f));
}

void DroneService::Stub::async::GetDronePose(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Pose* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDronePose_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Pose>* DroneService::Stub::PrepareAsyncGetDronePoseRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Pose, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetDronePose_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Pose>* DroneService::Stub::AsyncGetDronePoseRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetDronePoseRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status DroneService::Stub::SendDronePose(::grpc::ClientContext* context, const ::VCCSim::DronePose& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::DronePose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendDronePose_, context, request, response);
}

void DroneService::Stub::async::SendDronePose(::grpc::ClientContext* context, const ::VCCSim::DronePose* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::DronePose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendDronePose_, context, request, response, std::move(f));
}

void DroneService::Stub::async::SendDronePose(::grpc::ClientContext* context, const ::VCCSim::DronePose* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendDronePose_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* DroneService::Stub::PrepareAsyncSendDronePoseRaw(::grpc::ClientContext* context, const ::VCCSim::DronePose& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::DronePose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendDronePose_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* DroneService::Stub::AsyncSendDronePoseRaw(::grpc::ClientContext* context, const ::VCCSim::DronePose& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendDronePoseRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status DroneService::Stub::SendDronePath(::grpc::ClientContext* context, const ::VCCSim::DronePath& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::DronePath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendDronePath_, context, request, response);
}

void DroneService::Stub::async::SendDronePath(::grpc::ClientContext* context, const ::VCCSim::DronePath* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::DronePath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendDronePath_, context, request, response, std::move(f));
}

void DroneService::Stub::async::SendDronePath(::grpc::ClientContext* context, const ::VCCSim::DronePath* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendDronePath_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* DroneService::Stub::PrepareAsyncSendDronePathRaw(::grpc::ClientContext* context, const ::VCCSim::DronePath& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::DronePath, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendDronePath_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* DroneService::Stub::AsyncSendDronePathRaw(::grpc::ClientContext* context, const ::VCCSim::DronePath& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendDronePathRaw(context, request, cq);
  result->StartCall();
  return result;
}

DroneService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DroneService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DroneService::Service, ::VCCSim::RobotName, ::VCCSim::Pose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DroneService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Pose* resp) {
               return service->GetDronePose(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DroneService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DroneService::Service, ::VCCSim::DronePose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DroneService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::DronePose* req,
             ::VCCSim::Status* resp) {
               return service->SendDronePose(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DroneService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DroneService::Service, ::VCCSim::DronePath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DroneService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::DronePath* req,
             ::VCCSim::Status* resp) {
               return service->SendDronePath(ctx, req, resp);
             }, this)));
}

DroneService::Service::~Service() {
}

::grpc::Status DroneService::Service::GetDronePose(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Pose* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DroneService::Service::SendDronePose(::grpc::ServerContext* context, const ::VCCSim::DronePose* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DroneService::Service::SendDronePath(::grpc::ServerContext* context, const ::VCCSim::DronePath* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* CarService_method_names[] = {
  "/VCCSim.CarService/GetCarOdom",
  "/VCCSim.CarService/SendCarPose",
  "/VCCSim.CarService/SendCarPath",
};

std::unique_ptr< CarService::Stub> CarService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< CarService::Stub> stub(new CarService::Stub(channel, options));
  return stub;
}

CarService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetCarOdom_(CarService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendCarPose_(CarService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendCarPath_(CarService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status CarService::Stub::GetCarOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::VCCSim::Odometry* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetCarOdom_, context, request, response);
}

void CarService::Stub::async::GetCarOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetCarOdom_, context, request, response, std::move(f));
}

void CarService::Stub::async::GetCarOdom(::grpc::ClientContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetCarOdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* CarService::Stub::PrepareAsyncGetCarOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Odometry, ::VCCSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetCarOdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Odometry>* CarService::Stub::AsyncGetCarOdomRaw(::grpc::ClientContext* context, const ::VCCSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetCarOdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CarService::Stub::SendCarPose(::grpc::ClientContext* context, const ::VCCSim::CarPose& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::CarPose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendCarPose_, context, request, response);
}

void CarService::Stub::async::SendCarPose(::grpc::ClientContext* context, const ::VCCSim::CarPose* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::CarPose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendCarPose_, context, request, response, std::move(f));
}

void CarService::Stub::async::SendCarPose(::grpc::ClientContext* context, const ::VCCSim::CarPose* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendCarPose_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* CarService::Stub::PrepareAsyncSendCarPoseRaw(::grpc::ClientContext* context, const ::VCCSim::CarPose& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::CarPose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendCarPose_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* CarService::Stub::AsyncSendCarPoseRaw(::grpc::ClientContext* context, const ::VCCSim::CarPose& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendCarPoseRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CarService::Stub::SendCarPath(::grpc::ClientContext* context, const ::VCCSim::CarPath& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::CarPath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendCarPath_, context, request, response);
}

void CarService::Stub::async::SendCarPath(::grpc::ClientContext* context, const ::VCCSim::CarPath* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::CarPath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendCarPath_, context, request, response, std::move(f));
}

void CarService::Stub::async::SendCarPath(::grpc::ClientContext* context, const ::VCCSim::CarPath* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendCarPath_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* CarService::Stub::PrepareAsyncSendCarPathRaw(::grpc::ClientContext* context, const ::VCCSim::CarPath& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::CarPath, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendCarPath_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* CarService::Stub::AsyncSendCarPathRaw(::grpc::ClientContext* context, const ::VCCSim::CarPath& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendCarPathRaw(context, request, cq);
  result->StartCall();
  return result;
}

CarService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CarService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CarService::Service, ::VCCSim::RobotName, ::VCCSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::RobotName* req,
             ::VCCSim::Odometry* resp) {
               return service->GetCarOdom(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CarService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CarService::Service, ::VCCSim::CarPose, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::CarPose* req,
             ::VCCSim::Status* resp) {
               return service->SendCarPose(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CarService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CarService::Service, ::VCCSim::CarPath, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::CarPath* req,
             ::VCCSim::Status* resp) {
               return service->SendCarPath(ctx, req, resp);
             }, this)));
}

CarService::Service::~Service() {
}

::grpc::Status CarService::Service::GetCarOdom(::grpc::ServerContext* context, const ::VCCSim::RobotName* request, ::VCCSim::Odometry* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CarService::Service::SendCarPose(::grpc::ServerContext* context, const ::VCCSim::CarPose* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CarService::Service::SendCarPath(::grpc::ServerContext* context, const ::VCCSim::CarPath* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* MeshService_method_names[] = {
  "/VCCSim.MeshService/SendMesh",
};

std::unique_ptr< MeshService::Stub> MeshService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< MeshService::Stub> stub(new MeshService::Stub(channel, options));
  return stub;
}

MeshService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_SendMesh_(MeshService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status MeshService::Stub::SendMesh(::grpc::ClientContext* context, const ::VCCSim::MeshData& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::MeshData, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendMesh_, context, request, response);
}

void MeshService::Stub::async::SendMesh(::grpc::ClientContext* context, const ::VCCSim::MeshData* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::MeshData, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendMesh_, context, request, response, std::move(f));
}

void MeshService::Stub::async::SendMesh(::grpc::ClientContext* context, const ::VCCSim::MeshData* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendMesh_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* MeshService::Stub::PrepareAsyncSendMeshRaw(::grpc::ClientContext* context, const ::VCCSim::MeshData& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::MeshData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendMesh_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* MeshService::Stub::AsyncSendMeshRaw(::grpc::ClientContext* context, const ::VCCSim::MeshData& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendMeshRaw(context, request, cq);
  result->StartCall();
  return result;
}

MeshService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      MeshService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< MeshService::Service, ::VCCSim::MeshData, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](MeshService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::MeshData* req,
             ::VCCSim::Status* resp) {
               return service->SendMesh(ctx, req, resp);
             }, this)));
}

MeshService::Service::~Service() {
}

::grpc::Status MeshService::Service::SendMesh(::grpc::ServerContext* context, const ::VCCSim::MeshData* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* PointCloudService_method_names[] = {
  "/VCCSim.PointCloudService/SendPointCloudWithColor",
};

std::unique_ptr< PointCloudService::Stub> PointCloudService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< PointCloudService::Stub> stub(new PointCloudService::Stub(channel, options));
  return stub;
}

PointCloudService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_SendPointCloudWithColor_(PointCloudService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status PointCloudService::Stub::SendPointCloudWithColor(::grpc::ClientContext* context, const ::VCCSim::PointCloudWithColor& request, ::VCCSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::VCCSim::PointCloudWithColor, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendPointCloudWithColor_, context, request, response);
}

void PointCloudService::Stub::async::SendPointCloudWithColor(::grpc::ClientContext* context, const ::VCCSim::PointCloudWithColor* request, ::VCCSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::VCCSim::PointCloudWithColor, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendPointCloudWithColor_, context, request, response, std::move(f));
}

void PointCloudService::Stub::async::SendPointCloudWithColor(::grpc::ClientContext* context, const ::VCCSim::PointCloudWithColor* request, ::VCCSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendPointCloudWithColor_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* PointCloudService::Stub::PrepareAsyncSendPointCloudWithColorRaw(::grpc::ClientContext* context, const ::VCCSim::PointCloudWithColor& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::VCCSim::Status, ::VCCSim::PointCloudWithColor, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendPointCloudWithColor_, context, request);
}

::grpc::ClientAsyncResponseReader< ::VCCSim::Status>* PointCloudService::Stub::AsyncSendPointCloudWithColorRaw(::grpc::ClientContext* context, const ::VCCSim::PointCloudWithColor& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendPointCloudWithColorRaw(context, request, cq);
  result->StartCall();
  return result;
}

PointCloudService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      PointCloudService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< PointCloudService::Service, ::VCCSim::PointCloudWithColor, ::VCCSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](PointCloudService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::VCCSim::PointCloudWithColor* req,
             ::VCCSim::Status* resp) {
               return service->SendPointCloudWithColor(ctx, req, resp);
             }, this)));
}

PointCloudService::Service::~Service() {
}

::grpc::Status PointCloudService::Service::SendPointCloudWithColor(::grpc::ServerContext* context, const ::VCCSim::PointCloudWithColor* request, ::VCCSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace VCCSim

